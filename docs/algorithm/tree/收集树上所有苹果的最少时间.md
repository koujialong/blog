# 收集树上所有苹果的最少时间 LC1443

## 题目
* '[false,false,true,false,true,true,false]'
* 给你一棵有 n 个节点的无向树，节点编号为 0 到 n-1 ，它们中有一些节点有苹果。通过树上的一条边，需要花费 1 秒钟。你从 节点 0 出发，请你返回最少需要多少秒，可以收集到所有苹果，并回到节点 0 。
* 无向树的边由 edges 给出，其中 edges[i] = [fromi, toi] ，表示有一条边连接 from 和 toi 。除此以外，还有一个布尔数组 hasApple ，其中 hasApple[i] = true 代表节点 i 有一个苹果，否则，节点 i 没有苹果。
![img](/img/1443_1.png)
* 输入：n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]
* 输出：8
* 解释：上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。

## 题解
```javascript
/**
 * @param {number} n
 * @param {number[][]} edges
 * @param {boolean[]} hasApple
 * @return {number}
 */
var minTime = function(n, edges, hasApple) {
    // 初始化哈希表
    const m={}
    // 将边数据的【a,b】转换为 {b:a}形式哈希表
    for (const edge of edges) {
        if(m[edge[1]]!==undefined){
            // 如果有哈希表已存在值，则反向存入{a:b}
            m[edge[0]]=edge[1]
        }
        else{
            m[edge[1]]=edge[0]
        }
    }

    let res=0;
    // 循环有值数组
    for (let i = 0; i < hasApple.length; i++) {
        // 如果没有值则跳出循环
        if(!hasApple[i]) continue;
        let p=i;
        // 从有值节点向根节点遍历所有未遍历过的节点
        while(p!=0&&m[p]>=0){
            const temp=m[p];
            // 当前遍历节点赋值-1标识已遍历过
            m[p]=-1
            // 设置要遍历的下一节点
            p=temp
            // 每遍历一个节点结果值+2
            res+=2
        }
    }
    return res;
};
```
