# 解码方法 LC91
## 题目
* 一条包含字母 A-Z 的消息通过以下映射进行了 编码
```text
'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
```
要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"`11106`" 可以映射为：
* "`AAJF`" ，将消息分组为 (1 1 10 6)
* "`KJF`" ，将消息分组为 (11 10 6)

* 注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。
* 给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。

* 输入：s = "226"
* 输出：3
* 解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。

## 题解
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var numDecodings = function (s) {
  const m = s.length;
  // 空字符串返回0
  if (s === null || m === 0) return 0;
  // 字符串为0返回0
  if (s[0] === "0") return 0;
  // 初始化动态规划数组，因为需要dp方程判断最大的位数为两位，所以需要在原始数组前面补足一位长度为m+1
  const dp = new Array(m + 1).fill(0);
  // 补足位默认值为1，因为前两位满足两位dp方程，题解加1
  dp[0]=1;
  // 第一位设置为1，应为单个数字永远题解为1
  dp[1]=1;
  for (let i = 2; i < dp.length; i++) {
    // 获取当前归还最后一位数字
    const a = Number(s.slice(i - 1, i));
    if (a >= 1 && a <= 9) {
      // 满足一位数字条件当前位置题解为前一位题解加当前题解
      dp[i] += dp[i - 1];
    }
    const b = Number(s.slice(i - 2, i));
    if (b >= 10 && b <= 26) {
      // 满足两位数字条件当前位置题解为前两位题解加当前题解
      dp[i] += dp[i - 2];
    }
  }
  // 最终解为dp数组最后一位
  return dp[m];
};
```
